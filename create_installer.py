#!/usr/bin/env python3
"""
HALbasic Windows Installer Creation Script
Creates a comprehensive Windows installer for HALbasic LINAC monitoring application
Developer: gobioeng.com
Date: 2025-01-21
"""

import os
import sys
import shutil
import subprocess
import argparse
from pathlib import Path

class HALbasicInstaller:
    """Comprehensive installer creator for HALbasic application"""
    
    def __init__(self, build_type="onedir"):
        self.build_type = build_type  # "onedir" or "onefile"
        self.app_name = "HALbasic"
        self.app_version = "0.0.1"
        self.company = "gobioeng.com"
        self.description = "Professional LINAC Water System Monitor"
        
        # Paths
        self.project_root = Path(__file__).parent
        self.build_dir = self.project_root / "build"
        self.dist_dir = self.project_root / "dist"
        self.spec_file = self.project_root / f"{self.app_name}.spec"
        
    def clean_build_directories(self):
        """Clean previous build artifacts"""
        print("üßπ Cleaning previous build artifacts...")
        
        dirs_to_clean = [self.build_dir, self.dist_dir]
        for dir_path in dirs_to_clean:
            if dir_path.exists():
                shutil.rmtree(dir_path)
                print(f"   Removed: {dir_path}")
        
        if self.spec_file.exists():
            os.remove(self.spec_file)
            print(f"   Removed: {self.spec_file}")
    
    def verify_dependencies(self):
        """Verify all required dependencies are installed"""
        print("üîç Verifying dependencies...")
        
        required_packages = [
            'PyQt5', 'pandas', 'numpy', 'matplotlib', 
            'scipy', 'pyinstaller', 'pyqtgraph'
        ]
        
        missing_packages = []
        for package in required_packages:
            try:
                __import__(package.lower() if package != 'PyQt5' else 'PyQt5')
                print(f"   ‚úì {package}")
            except ImportError:
                missing_packages.append(package)
                print(f"   ‚úó {package} - MISSING")
        
        if missing_packages:
            print(f"\n‚ùå Missing packages: {', '.join(missing_packages)}")
            print("Please install missing packages using:")
            print(f"pip install {' '.join(missing_packages)}")
            return False
        
        print("‚úÖ All dependencies verified")
        return True
    
    def create_spec_file(self):
        """Create PyInstaller spec file for HALbasic"""
        print("üìù Creating PyInstaller spec file...")
        
        # Define additional data files and hidden imports
        added_files = [
            ('data', 'data'),  # Include data directory
            ('assets', 'assets'),  # Include assets directory
        ]
        
        hidden_imports = [
            'PyQt5.QtCore', 'PyQt5.QtGui', 'PyQt5.QtWidgets',
            'matplotlib.backends.backend_qt5agg',
            'matplotlib.backends.backend_pdf',
            'pandas', 'numpy', 'scipy',
            'sklearn', 'pyqtgraph',
            'sqlalchemy', 'openpyxl'
        ]
        
        # Create spec file content
        spec_content = f"""# -*- mode: python ; coding: utf-8 -*-
# HALbasic PyInstaller Spec File
# Generated by create_installer.py

import sys
from pathlib import Path

block_cipher = None

# Application settings
APP_NAME = '{self.app_name}'
APP_VERSION = '{self.app_version}'
COMPANY = '{self.company}'
DESCRIPTION = '{self.description}'

a = Analysis(
    ['main.py'],
    pathex=['{self.project_root}'],
    binaries=[],
    datas={added_files},
    hiddenimports={hidden_imports},
    hookspath=[],
    hooksconfig={{}},
    runtime_hooks=[],
    excludes=[
        'tkinter', 'tk', 'tcl',  # Exclude Tkinter
        'PIL', 'Pillow',         # Exclude PIL if not needed
        'test', 'tests',         # Exclude test modules
        'distutils',             # Exclude distutils
        'setuptools',            # Exclude setuptools
        '_pytest',               # Exclude pytest
        'pytest',
        'sphinx',                # Exclude sphinx
        'IPython',               # Exclude IPython
        'jupyter',               # Exclude jupyter
    ],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
    noarchive=False,
)

# Remove duplicate packages to reduce size
pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

# Choose build type
"""

        if self.build_type == "onefile":
            spec_content += f"""
exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.zipfiles,
    a.datas,
    [],
    name=APP_NAME,
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,  # No console window
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    version='version_info.txt',
    icon='assets/halogo.ico'  # App icon
)
"""
        else:  # onedir
            spec_content += f"""
exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=True,
    name=APP_NAME,
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    console=False,  # No console window
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    version='version_info.txt',
    icon='assets/halogo.ico'  # App icon
)

coll = COLLECT(
    exe,
    a.binaries,
    a.zipfiles,
    a.datas,
    strip=False,
    upx=True,
    upx_exclude=[],
    name=APP_NAME,
)
"""
        
        # Write spec file
        with open(self.spec_file, 'w') as f:
            f.write(spec_content)
        
        print(f"‚úÖ Spec file created: {self.spec_file}")
    
    def create_version_info(self):
        """Create version information file for Windows executable"""
        print("üìÑ Creating version information...")
        
        version_info_content = f"""# UTF-8
#
# For more details about fixed file info 'ffi' see:
# http://msdn.microsoft.com/en-us/library/ms646997.aspx
VSVersionInfo(
  ffi=FixedFileInfo(
    filevers=({self.app_version.replace('.', ', ')}, 0),
    prodvers=({self.app_version.replace('.', ', ')}, 0),
    mask=0x3f,
    flags=0x0,
    OS=0x40004,
    fileType=0x1,
    subtype=0x0,
    date=(0, 0)
  ),
  kids=[
    StringFileInfo(
      [
        StringTable(
          u'040904B0',
          [StringStruct(u'CompanyName', u'{self.company}'),
          StringStruct(u'FileDescription', u'{self.description}'),
          StringStruct(u'FileVersion', u'{self.app_version}'),
          StringStruct(u'InternalName', u'{self.app_name}'),
          StringStruct(u'LegalCopyright', u'Copyright ¬© 2025 {self.company}'),
          StringStruct(u'OriginalFilename', u'{self.app_name}.exe'),
          StringStruct(u'ProductName', u'{self.app_name}'),
          StringStruct(u'ProductVersion', u'{self.app_version}')])
      ]), 
    VarFileInfo([VarStruct(u'Translation', [1033, 1200])])
  ]
)
"""
        
        version_file = self.project_root / "version_info.txt"
        with open(version_file, 'w') as f:
            f.write(version_info_content)
        
        print(f"‚úÖ Version info created: {version_file}")
    
    def ensure_assets_exist(self):
        """Ensure required assets exist or create fallbacks"""
        print("üé® Checking assets...")
        
        assets_dir = self.project_root / "assets"
        assets_dir.mkdir(exist_ok=True)
        
        # Check for icon file
        icon_file = assets_dir / "halogo.ico"
        if not icon_file.exists():
            # Try to find PNG and convert or create a default
            png_file = assets_dir / "halogo.png"
            if png_file.exists():
                print(f"   Converting {png_file} to ICO format...")
                try:
                    from PIL import Image
                    img = Image.open(png_file)
                    img.save(icon_file)
                    print(f"   ‚úì Created {icon_file}")
                except ImportError:
                    print("   ‚ö†Ô∏è PIL not available for ICO conversion")
                    print(f"   Using default icon handling")
            else:
                print(f"   ‚ö†Ô∏è No icon found at {icon_file}")
                print("   Application will use default icon")
    
    def build_application(self):
        """Build the application using PyInstaller"""
        print(f"üî® Building {self.app_name} ({self.build_type})...")
        
        # PyInstaller command
        cmd = [
            sys.executable, '-m', 'PyInstaller',
            '--clean',  # Clean build
            '--noconfirm',  # Overwrite without confirmation
            str(self.spec_file)
        ]
        
        print(f"Running: {' '.join(cmd)}")
        
        try:
            result = subprocess.run(cmd, cwd=self.project_root, 
                                  capture_output=True, text=True)
            
            if result.returncode == 0:
                print("‚úÖ Build completed successfully!")
                self._show_build_results()
            else:
                print("‚ùå Build failed!")
                print("STDOUT:", result.stdout)
                print("STDERR:", result.stderr)
                return False
        except Exception as e:
            print(f"‚ùå Build error: {e}")
            return False
        
        return True
    
    def _show_build_results(self):
        """Show build results and file locations"""
        print("\nüì¶ Build Results:")
        
        if self.build_type == "onedir":
            app_dir = self.dist_dir / self.app_name
            if app_dir.exists():
                exe_file = app_dir / f"{self.app_name}.exe"
                if exe_file.exists():
                    size_mb = exe_file.stat().st_size / (1024 * 1024)
                    print(f"   üìÅ Directory: {app_dir}")
                    print(f"   üöÄ Executable: {exe_file}")
                    print(f"   üìè Exe Size: {size_mb:.1f} MB")
                    
                    # Count total files
                    total_files = sum(1 for _ in app_dir.rglob('*') if _.is_file())
                    total_size = sum(f.stat().st_size for f in app_dir.rglob('*') if f.is_file())
                    total_size_mb = total_size / (1024 * 1024)
                    
                    print(f"   üìä Total Files: {total_files}")
                    print(f"   üíæ Total Size: {total_size_mb:.1f} MB")
        else:  # onefile
            exe_file = self.dist_dir / f"{self.app_name}.exe"
            if exe_file.exists():
                size_mb = exe_file.stat().st_size / (1024 * 1024)
                print(f"   üöÄ Executable: {exe_file}")
                print(f"   üìè Size: {size_mb:.1f} MB")
    
    def create_installer_script(self):
        """Create a simple installer script"""
        print("üì¶ Creating installer script...")
        
        # Create a simple batch file installer
        installer_script = f"""@echo off
echo Installing {self.app_name} {self.app_version}
echo Company: {self.company}
echo.

REM Create installation directory
set INSTALL_DIR=%PROGRAMFILES%\\{self.company}\\{self.app_name}
echo Creating installation directory: %INSTALL_DIR%
mkdir "%INSTALL_DIR%" 2>nul

REM Copy files
echo Copying application files...
xcopy /E /I /Y ".\\{self.app_name}\\*" "%INSTALL_DIR%\\"

REM Create desktop shortcut
echo Creating desktop shortcut...
set DESKTOP=%USERPROFILE%\\Desktop
echo Set oWS = WScript.CreateObject("WScript.Shell") > CreateShortcut.vbs
echo sLinkFile = "%DESKTOP%\\{self.app_name}.lnk" >> CreateShortcut.vbs
echo Set oLink = oWS.CreateShortcut(sLinkFile) >> CreateShortcut.vbs
echo oLink.TargetPath = "%INSTALL_DIR%\\{self.app_name}.exe" >> CreateShortcut.vbs
echo oLink.WorkingDirectory = "%INSTALL_DIR%" >> CreateShortcut.vbs
echo oLink.Description = "{self.description}" >> CreateShortcut.vbs
echo oLink.Save >> CreateShortcut.vbs
cscript CreateShortcut.vbs
del CreateShortcut.vbs

REM Create start menu entry
echo Creating start menu entry...
set STARTMENU=%APPDATA%\\Microsoft\\Windows\\Start Menu\\Programs
mkdir "%STARTMENU%\\{self.company}" 2>nul
echo Set oWS = WScript.CreateObject("WScript.Shell") > CreateStartMenu.vbs
echo sLinkFile = "%STARTMENU%\\{self.company}\\{self.app_name}.lnk" >> CreateStartMenu.vbs
echo Set oLink = oWS.CreateShortcut(sLinkFile) >> CreateStartMenu.vbs
echo oLink.TargetPath = "%INSTALL_DIR%\\{self.app_name}.exe" >> CreateStartMenu.vbs
echo oLink.WorkingDirectory = "%INSTALL_DIR%" >> CreateStartMenu.vbs
echo oLink.Description = "{self.description}" >> CreateStartMenu.vbs
echo oLink.Save >> CreateStartMenu.vbs
cscript CreateStartMenu.vbs
del CreateStartMenu.vbs

echo.
echo ‚úÖ {self.app_name} installation completed!
echo üöÄ You can now run {self.app_name} from:
echo    - Desktop shortcut
echo    - Start Menu -^> {self.company} -^> {self.app_name}
echo    - Direct path: %INSTALL_DIR%\\{self.app_name}.exe
echo.
pause
"""
        
        installer_file = self.dist_dir / "install.bat"
        with open(installer_file, 'w') as f:
            f.write(installer_script)
        
        print(f"‚úÖ Installer script created: {installer_file}")
    
    def create_readme(self):
        """Create README file for distribution"""
        print("üìö Creating README...")
        
        readme_content = f"""# {self.app_name} {self.app_version}

## {self.description}

**Developer:** {self.company}  
**Version:** {self.app_version}  
**Build Date:** {__import__('datetime').datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Installation

### Quick Install (Recommended)
1. Run `install.bat` as Administrator
2. Follow the installation prompts
3. Launch {self.app_name} from Desktop or Start Menu

### Manual Install
1. Copy the `{self.app_name}` folder to your desired location
2. Run `{self.app_name}.exe` from the copied folder
3. Create shortcuts manually if needed

## System Requirements

- Windows 10 or later (64-bit recommended)
- 4 GB RAM minimum (8 GB recommended)
- 500 MB free disk space
- Display resolution: 1280x720 or higher

## Features

- ‚úÖ Professional LINAC water system monitoring
- ‚úÖ Real-time trend analysis and visualization
- ‚úÖ Fault code lookup and management
- ‚úÖ Data import/export capabilities
- ‚úÖ Machine Performance Check (MPC) analysis
- ‚úÖ Comprehensive reporting tools
- ‚úÖ Modern, user-friendly interface

## Quick Start

1. Launch {self.app_name}
2. Import your LINAC log files using File ‚Üí Open Log File
3. Navigate through tabs to explore:
   - **Dashboard:** System overview and statistics
   - **Trends:** Parameter visualization and analysis
   - **Data Table:** Raw data browsing
   - **Analysis:** Advanced trend analysis
   - **MPC:** Machine performance checking
   - **Fault Codes:** Fault code lookup and notes

## Support

For technical support, feature requests, or bug reports:
- Website: https://{self.company}
- Email: support@{self.company}

## License

Copyright ¬© 2025 {self.company}. All rights reserved.

## Troubleshooting

### Application won't start
- Ensure all files are properly extracted
- Check system requirements
- Run as Administrator if needed
- Check Windows event logs for error details

### Missing data/graphs
- Verify log file format compatibility
- Ensure sufficient memory is available
- Check file permissions

### Performance issues
- Close other applications to free memory
- Use SSD storage for better performance
- Increase virtual memory if needed

---
**{self.app_name}** - Professional LINAC monitoring made simple.
"""
        
        readme_file = self.dist_dir / "README.txt"
        with open(readme_file, 'w') as f:
            f.write(readme_content)
        
        print(f"‚úÖ README created: {readme_file}")
    
    def run_full_build(self):
        """Run the complete build process"""
        print(f"üöÄ Starting {self.app_name} installer creation...")
        print(f"Build Type: {self.build_type}")
        print(f"Version: {self.app_version}")
        print(f"Company: {self.company}")
        print("=" * 60)
        
        try:
            # Step 1: Clean previous builds
            self.clean_build_directories()
            
            # Step 2: Verify dependencies
            if not self.verify_dependencies():
                return False
            
            # Step 3: Ensure assets exist
            self.ensure_assets_exist()
            
            # Step 4: Create version info
            self.create_version_info()
            
            # Step 5: Create spec file
            self.create_spec_file()
            
            # Step 6: Build application
            if not self.build_application():
                return False
            
            # Step 7: Create installer script
            self.create_installer_script()
            
            # Step 8: Create README
            self.create_readme()
            
            print("\n" + "=" * 60)
            print(f"üéâ {self.app_name} installer creation completed successfully!")
            print(f"üìÅ Distribution folder: {self.dist_dir}")
            print("üìã Next steps:")
            print("   1. Test the application by running the .exe file")
            print("   2. Run install.bat to test installation process")
            print("   3. Distribute the entire dist folder to users")
            print("=" * 60)
            
            return True
            
        except Exception as e:
            print(f"\n‚ùå Build process failed: {e}")
            import traceback
            traceback.print_exc()
            return False


def main():
    """Main function to run installer creation"""
    parser = argparse.ArgumentParser(
        description=f"Create Windows installer for HALbasic LINAC monitoring application"
    )
    parser.add_argument(
        '--type', 
        choices=['onedir', 'onefile'], 
        default='onedir',
        help='Build type: onedir (faster startup) or onefile (single executable)'
    )
    parser.add_argument(
        '--clean', 
        action='store_true',
        help='Clean build directories only (no build)'
    )
    
    args = parser.parse_args()
    
    installer = HALbasicInstaller(build_type=args.type)
    
    if args.clean:
        installer.clean_build_directories()
        print("‚úÖ Clean completed!")
        return True
    
    success = installer.run_full_build()
    return success


if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)